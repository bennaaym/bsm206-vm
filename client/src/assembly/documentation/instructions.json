{
    "instructions":
    {
        "ADD":
        {
            "function":"Adds the value operand to the value of the Accumulator",
            "modes":
            {
                "immediate" :{"opcode":"10","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"20","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"30","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"40","bytes":"2","cycles":"4"}
            }
        },
        "ADDC":
        {
            "function":"Adds the value operand to the value of the Accumulator,the carry flag will be added too",
            "modes":
            {
                "immediate" :{"opcode":"11","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"21","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"31","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"41","bytes":"2","cycles":"4"}
            }
        },
        "AND":
        {
            "function":"Performs a logical AND operation between the Accumulator value and the operand",
            "modes":
            {
                "immediate" :{"opcode":"12","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"22","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"32","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"42","bytes":"2","cycles":"4"}
            }
        },
        "CLR":
        {
            "function":"Sets the accumulator to zero",
            "modes":
            {
                "inherent"   :{"opcode":"01","bytes":"1","cycles":"1"}
            }
        },
        "DECR":
        {
            "function":"Decrements the value of the accumulator by 1",
            "modes":
            {
                "inherent"   :{"opcode":"02","bytes":"1","cycles":"1"}
            }
        },
        "DIV":
        {
            "function":"Divides the value of the Accumulator by the operand, the quotient will be stored in the Accumulator and the remainder will be stored in the Data register",
            "modes":
            {
                "immediate" :{"opcode":"15","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"25","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"35","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"45","bytes":"2","cycles":"4"}
            }
        },
        "XOR":
        {
            "function":"Performs a logical XOR operation between the Accumulator value and the operand",
            "modes":
            {
                "immediate" :{"opcode":"16","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"26","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"36","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"46","bytes":"2","cycles":"4"}
            }
        },
        "INCR":
        {
            "function":"Increments the value of the accumulator by 1",
            "modes":
            {
                "inherent"   :{"opcode":"03","bytes":"1","cycles":"1"}
            }
        },
        "COM":
        {
           "function":"Sets the value of the Accumulator to its 1's complement",
           "modes":
           {
                "inherent"   :{"opcode":"04","bytes":"1","cycles":"1"}
           }
        },
        "NEG":
        {
           "function":"Sets the value of the Accumulator to its 2's complement",
           "modes":
           {
                "inherent"   :{"opcode":"05","bytes":"1","cycles":"1"}
           }
        },
        "LDA":
        {
            "function":"Loads the operand to the Accumulator",
            "modes":
            {
                "immediate" :{"opcode":"1A","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"2A","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"3A","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"4A","bytes":"2","cycles":"4"}
            }
        },
        "OR":
        {
            "function":"Performs a logical OR operation between the Accumulator value and the operand",
            "modes":
            {
                "immediate" :{"opcode":"1B","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"2B","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"3B","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"4B","bytes":"2","cycles":"4"}
            }
        },
        "PSH":
        {
           "function":"Stores the value of the Accumulator into the memory address pointed by the Stack Pointer",
           "modes":
           {
                "inherent"   :{"opcode":"06","bytes":"1","cycles":"1"}
           } 
        },
        "PUL":
        {
           "function":"Pulls data from  the memory location pointed by the Stack Pointer and loads it into the Accumulator",
           "modes":
           {
                "inherent"   :{"opcode":"07","bytes":"1","cycles":"1"}
           }    
        },
        "SAR":
        {
           "function":"Zero fill right shift",
           "modes":
           {
                "inherent"   :{"opcode":"08","bytes":"1","cycles":"1"}
           }
        },
        "SAL":
        {
           "function":"Zero fill left shift",
           "modes":
           {
                "inherent"   :{"opcode":"09","bytes":"1","cycles":"1"}
           }
        },
        "SUB":
        {
            "function":"Substructures the value of the accumulator from operand ",
            "modes":
            {
                "immediate" :{"opcode":"1E","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"2E","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"3E","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"4E","bytes":"2","cycles":"4"}
            }
        },
        "SUBC":
        {
            "function":"Substructures the value of the accumulator from operand, the carry flag will be subtracted too",
            "modes":
            {
                "immediate" :{"opcode":"1F","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"2F","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"3F","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"4F","bytes":"2","cycles":"4"}
            }
        },
        "STA":
        {   "function":"Stores the accumulator value into memory",
            "modes":
            {
                "direct"    :{"opcode":"A0","bytes":"3","cycles":"5"},
                "indirect"  :{"opcode":"B0","bytes":"3","cycles":"8"},
                "index"     :{"opcode":"C0","bytes":"2","cycles":"3"}
            }
        },
        "MUL":
        {
            "function":"Multiplies the Low Byte of the Accumulator with The Low byte of the operand (8bits multiplication)",
            "modes":
            {           
                "immediate" :{"opcode":"95","bytes":"3","cycles":"3"},
                "direct"    :{"opcode":"A5","bytes":"3","cycles":"6"},
                "indirect"  :{"opcode":"B5","bytes":"3","cycles":"9"},
                "index"     :{"opcode":"C5","bytes":"2","cycles":"4"}
            }
        },
        "LDAX":
        {
            "function":"Loads the operand value into the Index register",
            "modes":
            {
                "immediate" :{"opcode":"91","bytes":"3","cycles":"2"},
                "direct"    :{"opcode":"A1","bytes":"3","cycles":"5"},
                "indirect"  :{"opcode":"B1","bytes":"3","cycles":"8"},
                "index"     :{"opcode":"C1","bytes":"2","cycles":"3"}
            }
        },
        "LDAS":
        {
            "function":"Loads the operand value into the Stack Pointer",
            "modes": 
            {
                "immediate" :{"opcode":"92","bytes":"3","cycles":"2"},
                "direct"    :{"opcode":"A2","bytes":"3","cycles":"5"},
                "indirect"  :{"opcode":"B2","bytes":"3","cycles":"8"},
                "index"     :{"opcode":"C2","bytes":"2","cycles":"3"}
            }
        },
        
        "STAX":
        {
            "function":"Stores the value of the Index register into memory",
            "modes": 
            {
                "direct"    :{"opcode":"A3","bytes":"3","cycles":"5"},
                "indirect"  :{"opcode":"B3","bytes":"3","cycles":"8"}
            }
        },

        "DECX":
        {
            "function":"Decrements the Index register by 1",
            "modes": 
            {
                "inherent"   :{"opcode":"0A","bytes":"1","cycles":"1"}
            }
        },
        "INCX":
        {
           "function":"Increments the Index register by 1",
           "modes":
           {
                "inherent"   :{"opcode":"0B","bytes":"1","cycles":"1"}
           }
        },
        
        "BRA":
        {
            "function":"Unconditional branching  to address, uses the byte after the opcode to calculate the effective address",
            "modes":
            {
                "relative" :{"opcode":"50","byte":"2","cycle":"1"}
            }
        },
        "BCC":
        {
            "function":"Conditional Branching  to address if C = 0, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"51","byte":"2","cycle":"1"}
            }
        },
        "BCS":
        {
            "function":"Conditional Branching  to address if C == 1, uses the byte after the opcode to calculate the effective address",
            "modes":
            {
                "relative" :{"opcode":"52","byte":"2","cycle":"1"}
            }
        },
        "BZR":
        {
            "function":"Conditional Branching  to address if Z == 1, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"53","byte":"2","cycle":"1"}
            }
        },
        "BMI":
        {
            "function":"Conditional Branching  to address if N == 1, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5A","byte":"2","cycle":"1"}
            }
        },
        "BNE":
        {
            "function":"Conditional Branching  to address if Z == 0, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5B","byte":"2","cycle":"1"}
            }
        },
        "BVC":
        {
            "function":"Conditional Branching  to address if V == 0, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5C","byte":"2","cycle":"1"}
            }
        },
        "BVS":
        {
            "function":"Conditional Branching  to address if V == 1, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5D","byte":"2","cycle":"1"}
            }
        },
        "BPL":
        {
            "function":"Conditional Branching  to address if N == 0, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5E","byte":"2","cycle":"1"}
            }
        },
        "BSR":
        {
            "function":"Unconditional branching to subroutine, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "relative" :{"opcode":"5F","byte":"2","cycle":"1"}
            }
        },
        "RTS":
        {
            "function":"Returns from subroutine",
            "modes": 
            {
                "inherent" :{"opcode":"8A","byte":"1","cycle":"4"}
            }
        },
        "JMP":
        {
            "function":"Unconditional jump to address, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "index" :{"opcode":"4C","byte":"2","cycle":"1"}
            }
        },
        "JSR":
        {
            "function":"Unconditional jump to subroutine, uses the byte after the opcode to calculate the effective address",
            "modes": 
            {
                "index" :{"opcode":"4D","byte":"2","cycle":"6"}
            }
        },
        "NOP":
        {
            "function":"No opeation",
            "modes":
            {
                "inherent" :{"opcode":"89","byte":"1","cycle":"1"}
            }
        },
        "HLT":
        {
            "function":"Halt the microprocessor",
            "modes": 
            {
                "inherent" :{"opcode":"0E","byte":"1","cycle":"1"}
            }
        },
        "CLC":
        {
            "function":"Sets the carry flag to 0",
            "modes": 
            {
                "inherent" :{"opcode":"83","byte":"1","cycle":"1"}
            }
        },
        "CLI":
        {
            "function":"Sets the interrupt flag to 0",
            "modes": 
            {
                "inherent" :{"opcode":"84","byte":"1","cycle":"1"}
            }
        },
        "CLV":
        {
            "function":"Sets the overflow flag to 0",
            "modes": 
            {
                "inherent" :{"opcode":"85","byte":"1","cycle":"1"}                
            }
        },
        "STC":
        {
            "function":"Sets the carry flag to 1",
            "modes": 
            {
                "inherent" :{"opcode":"86","byte":"1","cycle":"1"}
            }
        },
        "STI":
        {
            "function":"Sets the interrupt flag to 1",
            "modes": 
            {
                "inherent" :{"opcode":"87","byte":"1","cycle":"1"}
            }
        },
        "STV":
        {
            "function":"Sets the overflow flag to 1",
            "modes": 
            {
                "inherent" :{"opcode":"88","byte":"1","cycle":"1"}
            }
        } 
    }
}